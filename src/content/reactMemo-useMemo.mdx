import { CodeBlock } from "../components/CodeBlock";
import Box from "../components/Box.jsx"

# Оптимизация производительности с React.memo и useMemo

В React есть несколько способов оптимизации производительности компонентов, и два из них — это React.memo и useMemo.

### React.memo

React.memo — это функция высшего порядка (HOC), которая используется для оптимизации функциональных компонентов. Она предотвращает ненужные повторные рендеры, если пропсы компонента не изменились.

### Что принимает и что возвращает `React.memo`?

**Принимает (`React.memo(Component, compareFunction?)`):**

1. **Компонент** (обязательный параметр) – функциональный компонент, который нужно мемоизировать.
2. **Функцию сравнения пропсов** (необязательный параметр) – кастомная функция для сравнения старых и новых пропсов.

**Возвращает:**

- Новый мемоизированный компонент, который ререндерится только при изменении пропсов.

Например, есть базовый компонент, который просто выводит имя. Этот компонент используется в родителе, у которого есть состояние (например, счётчик):

<CodeBlock code={`const Greeting = ({ name }) => {
    console.log('Рендер Greeting');
    return <h1>Привет, {name}!</h1>;
  };

  function App() {
    const [count, setCount] = useState(0);

    return (
      <div>
        <Greeting name={"Павел"} />
        <button onClick={() => setCount(count => count + 1)}>Увеличить {count}</button>
      </div>
    );
}`} language="javascript" />

Ты кликаешь по кнопке, счётчик меняется, но... **Greeting ререндерится каждый раз!**Потому что React **не знает**, что `name={"Павел"}` остаётся неизменным. Он просто перерисовывает всё дерево компонентов.

Теперь давай применим `React.memo`:

<CodeBlock code={`const GreetingComponent = ({ name }) => {
    console.log('Рендер Greeting');
    return <h1>Привет, {name}!</h1>;
  };

const Greeting = React.memo(GreetingComponent);`} language="javascript" />

Greeting не будет ререндериться! React просто сравнит пропсы (name в нашем случае), увидит, что они не изменились, и не будет трогать компонент.

По умолчанию React.memo сравнивает пропсы поверхностно. Примитивные значения (string, number,...) работают корректно, но объекты и массивы сравниваются по ссылке, что может вызывать ненужные ререндеры.

**Что принимает?**

Функция получает два аргумента:

1. `prevProps` — **предыдущие пропсы** компонента.
2. `nextProps` — **новые пропсы**, с которыми React хочет ререндерить компонент.

**Что должна вернуть?**

- **`true`** → если пропсы **не изменились**, компонент **НЕ** будет ререндериться.
- **`false`** → если пропсы **изменились**, компонент **перерисуется**.


<CodeBlock code={`const GreetingComponent = ({ name }) => {
    console.log('Рендер Greeting');
    return <h1>Привет, {name}!</h1>;
  };

const Greeting = React.memo(GreetingComponent);`} language="javascript" />

<Box type="warning" title="Важно!">
- `React.memo` сравнивает пропсы поверхностно - объекты и массивы сравниваются по ссылке.
- Для сложных пропсов нужна кастомная функция сравнения.
- Используй `useMemo` или `useCallback`, если передаёшь изменяемые значения.
</Box>

### useMemo

useMemo — это хук для оптимизации производительности, который позволяет кэшировать результаты вычислений и избегать ненужных пересчётов при каждом рендере. Он позволяет сохранять результат вычислений и повторно использовать его, если входные значения (зависимости) не изменились.

**Принимает** `useMemo(() => computeValue, [dependencies])`:

1. Функция – вычисляемое значение, которое нужно кэшировать.
2. Массив зависимостей – список значений, при изменении которых вычисление будет выполняться заново.

**Возвращает:**

- Мемоизированное (кэшированное) значение – результат работы переданной функции.

<CodeBlock code={`const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);`} language="javascript" />

- Если `a` и `b` не изменились → возвращается **старый закэшированный результат**.
- Если `a` или `b` изменились → вызывается `computeExpensiveValue()`, и React сохраняет новый результат.

<CodeBlock code={`function App({ number }) {
    const squared = useMemo(() => {
      console.log('Выполняем тяжёлый расчёт...');
      return number ** 2;
    }, [number]);

    return <p>Результат: {squared}</p>;
}`} language="javascript" />

Функция slowFunction вызывается только тогда, когда number изменяется.

<Box type="info" title="Официальная документация:">
React.memo: https://react.dev/reference/react/memo

useMemo: https://react.dev/reference/react/useMemo
</Box>


