import { CodeBlock } from "../components/CodeBlock";
import Box from "../components/Box.jsx"

# LifeCycle

LifeCycle("жизненный цикл") в React - это набор этапов, через которые компонент проходит, чтобы правильно работать на странице.
В React у компонентов есть свои "шаги", которые они проходят, когда создаются, обновляются или удаляются. Эти шаги называются "жизненным циклом" компонента.

Например, у компонента есть специальные моменты, когда он:

- рождается (это как включение робота)
- обновляется (как если бы робот начал выполнять другие действия)
- умирает (как если бы робота выключили).

Ты можешь использовать эти этапы, чтобы выполнять разные действия, чаще всего загружать данные с сервера, обновлять информацию на странице или очищать ресурсы, когда компонент больше не нужен.

### Основные этапы жизненного цикла в классовых компонентах

#### 1. Монтирование (Mounting)

Это этап, когда компонент создаётся и вставляется в DOM.

**Основные методы:**

- **`constructor`:** Здесь происходит инициализация состояния и привязка методов.

<CodeBlock code={`constructor(props) {
    super(props);
    this.state = { data: null };
}`} language="javascript" />

- **`render`:** Метод, который возвращает JSX-разметку. Вызывается при создании и обновлении компонента.
- **`componentDidMount`:** Вызывается один раз после того, как компонент вставлен в DOM. Отличное место для запросов к серверу, подписки на события или установки таймеров.

<CodeBlock code={`componentDidMount() {
    fetch('https://api.example.com/data')
      .then(response => response.json())
      .then(data => this.setState({ data }));
}`} language="javascript" />

#### 2. Обновление (Updating)

Компонент может обновляться, когда изменяются его **props** или **state**.

**Основные методы:**

- **`shouldComponentUpdate`:** Позволяет контролировать, следует ли перерисовывать компонент. Можно использовать для оптимизации производительности.
- **`render`:** Вызывается снова для обновления отображения.
- **`componentDidUpdate`:** Вызывается сразу после обновления компонента. Здесь можно, например, реагировать на изменение данных, выполнять дополнительные запросы или работать с изменённым DOM.

<CodeBlock code={`componentDidUpdate(prevProps, prevState) {
    if (prevState.data !== this.state.data) {
      console.log('Данные обновились!');
    }
}`} language="javascript" />

#### 3. Размонтирование (Unmounting)
Это момент, когда компонент удаляется из DOM.

**Основной метод:**
- **`componentWillUnmount`:** Здесь происходит очистка: отписка от событий, остановка таймеров, отмена сетевых запросов. Это помогает избежать утечек памяти.

<CodeBlock code={`componentWillUnmount() {
    // Отписываемся от событий, очищаем таймеры и т.д.
    console.log('Компонент удалён');
}`} language="javascript" />

#### 4. Обработка ошибок (Error Handling)

Если во время работы компонента происходит ошибка, можно её перехватить и обработать.

**Методы:**

- **`static getDerivedStateFromError(error)`:** Позволяет обновить состояние, чтобы отобразить запасной UI при возникновении ошибки.
- **`componentDidCatch(error, info)`:** Позволяет записать информацию об ошибке или отправить её на сервер для дальнейшего анализа.

### Жизненный цикл функциональных компонентов

Сегодня большинство разработчиков используют функциональные компоненты, а не классовые. Вместо методов жизненного цикла в классах здесь применяется хук **useEffect.**

**`useEffect`** - это хук в React, предназначенный для работы с методами жизненного цикла в функциональных компонентах.
По сути вот ОДИН ТАКОЙ ХУК заменяет ОСНОВНЫЕ методы жизненного цикла.
- **Первый параметр**: **Функция**, которая должна выполниться при монтировании компонента и при каждом обновлении.
- **Второй параметр**: **Массив зависимостей** определяет, на что конкретно должен реагировать **`useEffect`**. Если массив пуст, **`useEffect`** выполняется только при монтировании и размонтировании. Если в массиве указаны определенные значения, то **`useEffect`** будет выполняться только тогда, когда эти значения изменяются.

<CodeBlock code={`// Отработает как componentDidMount
useEffect(() => { console.log("componentDidMount") }, [])

// Отработает как componentDidUpdate (но есть прикол. Покажу ниже)
useEffect(() => { console.log("componentDidUpdate") }, [dependency])

// Отработает как componentDidMount и componentDidUpdate
useEffect(() => { console.log("componentDidMount и componentDidUpdate") })

// Отработает как componentWillUnmount
useEffect(() => {
    return () => console.log('componentWillUnmount')
}, [])`} language="javascript" />

1. **Mounting** (Монтирование)**:**
    - **`useEffect(() => {}, [])`**: Заменяет **`componentDidMount()`**. Выполняет побочные эффекты только один раз после монтирования.
    Передавая пустой массив зависимостей **`[]`**, можно сделать хук **`useEffect`** аналогом**`componentDidMount`**.
2. **Updating** (Обновление)**:**
    - **`useEffect(() => {}, [dependency])`**: Заменяет **`componentDidUpdate()`**. ****Позволяет указать зависимость для выполнения функции **только при изменении определенных props или state**.
    Что передашь, за тем и будет следить и при изменении вызовет функцию.
    - **`useEffect(() => {})`**: Выполняет функцию после каждого рендеринга компонента. Отрабатывает как  **`componentDidMount()`** и **`componentDidUpdate()`**.

<CodeBlock code={`// Отработает как componentDidUpdate
useEffect(() => { console.log("componentDidUpdate") }, [dependency]) `} language="javascript" />

3. **Unmounting** (Размонтирование)**:**
    - **`useEffect(() => () => {})`**: Заменяет **`componentWillUnmount()`**. Выполняет очистку и отписку от побочных эффектов при размонтировании (удалении из DOM) компонента.

<Box type="warning" title="Важно!">
 В React хуки, такие как **`useEffect`**, выполняются при каждом рендере компонента, включая первый рендер после монтирования. Это особенность работы хуков, и они
**не повторяют точно поведение** метода жизненного цикла **`componentDidMount`** из классовых компонентов. Таким образом, при первом рендере компонента useEffect также
будет вызван, даже если он имеет зависимость и при этом первоначальное значение зависимости не изменилось. Это не является ошибкой, а предполагаемое поведение хуков.
</Box>

<Box type="info" title="Официальная документация:">
https://react.dev/reference/react/useEffect
</Box>

